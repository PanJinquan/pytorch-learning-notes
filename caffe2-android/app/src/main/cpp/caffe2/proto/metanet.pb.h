// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/metanet.proto

#ifndef PROTOBUF_caffe2_2fproto_2fmetanet_2eproto__INCLUDED
#define PROTOBUF_caffe2_2fproto_2fmetanet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "caffe2/proto/caffe2.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_caffe2_2fproto_2fmetanet_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsModelInfoImpl();
void InitDefaultsModelInfo();
void InitDefaultsBlobsMapImpl();
void InitDefaultsBlobsMap();
void InitDefaultsNetsMapImpl();
void InitDefaultsNetsMap();
void InitDefaultsPlansMapImpl();
void InitDefaultsPlansMap();
void InitDefaultsStringMapImpl();
void InitDefaultsStringMap();
void InitDefaultsMetaNetDefImpl();
void InitDefaultsMetaNetDef();
inline void InitDefaults() {
  InitDefaultsModelInfo();
  InitDefaultsBlobsMap();
  InitDefaultsNetsMap();
  InitDefaultsPlansMap();
  InitDefaultsStringMap();
  InitDefaultsMetaNetDef();
}
}  // namespace protobuf_caffe2_2fproto_2fmetanet_2eproto
namespace caffe2 {
class BlobsMap;
class BlobsMapDefaultTypeInternal;
extern BlobsMapDefaultTypeInternal _BlobsMap_default_instance_;
class MetaNetDef;
class MetaNetDefDefaultTypeInternal;
extern MetaNetDefDefaultTypeInternal _MetaNetDef_default_instance_;
class ModelInfo;
class ModelInfoDefaultTypeInternal;
extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class NetsMap;
class NetsMapDefaultTypeInternal;
extern NetsMapDefaultTypeInternal _NetsMap_default_instance_;
class PlansMap;
class PlansMapDefaultTypeInternal;
extern PlansMapDefaultTypeInternal _PlansMap_default_instance_;
class StringMap;
class StringMapDefaultTypeInternal;
extern StringMapDefaultTypeInternal _StringMap_default_instance_;
}  // namespace caffe2
namespace caffe2 {

// ===================================================================

class ModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.ModelInfo) */ {
 public:
  ModelInfo();
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelInfo(ModelInfo&& from) noexcept
    : ModelInfo() {
    *this = ::std::move(from);
  }

  inline ModelInfo& operator=(ModelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo* internal_default_instance() {
    return reinterpret_cast<const ModelInfo*>(
               &_ModelInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ModelInfo* other);
  friend void swap(ModelInfo& a, ModelInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ModelInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string project = 1;
  bool has_project() const;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // optional string modelClass = 2;
  bool has_modelclass() const;
  void clear_modelclass();
  static const int kModelClassFieldNumber = 2;
  const ::std::string& modelclass() const;
  void set_modelclass(const ::std::string& value);
  #if LANG_CXX11
  void set_modelclass(::std::string&& value);
  #endif
  void set_modelclass(const char* value);
  void set_modelclass(const char* value, size_t size);
  ::std::string* mutable_modelclass();
  ::std::string* release_modelclass();
  void set_allocated_modelclass(::std::string* modelclass);

  // optional string version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string predictorType = 4 [default = "SINGLE_PREDICTOR"];
  bool has_predictortype() const;
  void clear_predictortype();
  static const int kPredictorTypeFieldNumber = 4;
  const ::std::string& predictortype() const;
  void set_predictortype(const ::std::string& value);
  #if LANG_CXX11
  void set_predictortype(::std::string&& value);
  #endif
  void set_predictortype(const char* value);
  void set_predictortype(const char* value, size_t size);
  ::std::string* mutable_predictortype();
  ::std::string* release_predictortype();
  void set_allocated_predictortype(::std::string* predictortype);

  // optional string modelId = 5;
  bool has_modelid() const;
  void clear_modelid();
  static const int kModelIdFieldNumber = 5;
  const ::std::string& modelid() const;
  void set_modelid(const ::std::string& value);
  #if LANG_CXX11
  void set_modelid(::std::string&& value);
  #endif
  void set_modelid(const char* value);
  void set_modelid(const char* value, size_t size);
  ::std::string* mutable_modelid();
  ::std::string* release_modelid();
  void set_allocated_modelid(::std::string* modelid);

  // @@protoc_insertion_point(class_scope:caffe2.ModelInfo)
 private:
  void set_has_project();
  void clear_has_project();
  void set_has_modelclass();
  void clear_has_modelclass();
  void set_has_version();
  void clear_has_version();
  void set_has_predictortype();
  void clear_has_predictortype();
  void set_has_modelid();
  void clear_has_modelid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr modelclass_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_predictortype_;
  ::google::protobuf::internal::ArenaStringPtr predictortype_;
  ::google::protobuf::internal::ArenaStringPtr modelid_;
  friend struct ::protobuf_caffe2_2fproto_2fmetanet_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fmetanet_2eproto::InitDefaultsModelInfoImpl();
};
// -------------------------------------------------------------------

class BlobsMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.BlobsMap) */ {
 public:
  BlobsMap();
  virtual ~BlobsMap();

  BlobsMap(const BlobsMap& from);

  inline BlobsMap& operator=(const BlobsMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlobsMap(BlobsMap&& from) noexcept
    : BlobsMap() {
    *this = ::std::move(from);
  }

  inline BlobsMap& operator=(BlobsMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobsMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlobsMap* internal_default_instance() {
    return reinterpret_cast<const BlobsMap*>(
               &_BlobsMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(BlobsMap* other);
  friend void swap(BlobsMap& a, BlobsMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlobsMap* New() const PROTOBUF_FINAL { return New(NULL); }

  BlobsMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlobsMap& from);
  void MergeFrom(const BlobsMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlobsMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_value(int index, ::std::string&& value);
  #endif
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  #if LANG_CXX11
  void add_value(::std::string&& value);
  #endif
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:caffe2.BlobsMap)
 private:
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct ::protobuf_caffe2_2fproto_2fmetanet_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fmetanet_2eproto::InitDefaultsBlobsMapImpl();
};
// -------------------------------------------------------------------

class NetsMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.NetsMap) */ {
 public:
  NetsMap();
  virtual ~NetsMap();

  NetsMap(const NetsMap& from);

  inline NetsMap& operator=(const NetsMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetsMap(NetsMap&& from) noexcept
    : NetsMap() {
    *this = ::std::move(from);
  }

  inline NetsMap& operator=(NetsMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetsMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetsMap* internal_default_instance() {
    return reinterpret_cast<const NetsMap*>(
               &_NetsMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NetsMap* other);
  friend void swap(NetsMap& a, NetsMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetsMap* New() const PROTOBUF_FINAL { return New(NULL); }

  NetsMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetsMap& from);
  void MergeFrom(const NetsMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetsMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required .caffe2.NetDef value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::caffe2::NetDef& value() const;
  ::caffe2::NetDef* release_value();
  ::caffe2::NetDef* mutable_value();
  void set_allocated_value(::caffe2::NetDef* value);

  // @@protoc_insertion_point(class_scope:caffe2.NetsMap)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::caffe2::NetDef* value_;
  friend struct ::protobuf_caffe2_2fproto_2fmetanet_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fmetanet_2eproto::InitDefaultsNetsMapImpl();
};
// -------------------------------------------------------------------

class PlansMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.PlansMap) */ {
 public:
  PlansMap();
  virtual ~PlansMap();

  PlansMap(const PlansMap& from);

  inline PlansMap& operator=(const PlansMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlansMap(PlansMap&& from) noexcept
    : PlansMap() {
    *this = ::std::move(from);
  }

  inline PlansMap& operator=(PlansMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlansMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlansMap* internal_default_instance() {
    return reinterpret_cast<const PlansMap*>(
               &_PlansMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PlansMap* other);
  friend void swap(PlansMap& a, PlansMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlansMap* New() const PROTOBUF_FINAL { return New(NULL); }

  PlansMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlansMap& from);
  void MergeFrom(const PlansMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlansMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required .caffe2.PlanDef value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::caffe2::PlanDef& value() const;
  ::caffe2::PlanDef* release_value();
  ::caffe2::PlanDef* mutable_value();
  void set_allocated_value(::caffe2::PlanDef* value);

  // @@protoc_insertion_point(class_scope:caffe2.PlansMap)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::caffe2::PlanDef* value_;
  friend struct ::protobuf_caffe2_2fproto_2fmetanet_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fmetanet_2eproto::InitDefaultsPlansMapImpl();
};
// -------------------------------------------------------------------

class StringMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.StringMap) */ {
 public:
  StringMap();
  virtual ~StringMap();

  StringMap(const StringMap& from);

  inline StringMap& operator=(const StringMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringMap(StringMap&& from) noexcept
    : StringMap() {
    *this = ::std::move(from);
  }

  inline StringMap& operator=(StringMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringMap* internal_default_instance() {
    return reinterpret_cast<const StringMap*>(
               &_StringMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(StringMap* other);
  friend void swap(StringMap& a, StringMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringMap* New() const PROTOBUF_FINAL { return New(NULL); }

  StringMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StringMap& from);
  void MergeFrom(const StringMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StringMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:caffe2.StringMap)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_caffe2_2fproto_2fmetanet_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fmetanet_2eproto::InitDefaultsStringMapImpl();
};
// -------------------------------------------------------------------

class MetaNetDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.MetaNetDef) */ {
 public:
  MetaNetDef();
  virtual ~MetaNetDef();

  MetaNetDef(const MetaNetDef& from);

  inline MetaNetDef& operator=(const MetaNetDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaNetDef(MetaNetDef&& from) noexcept
    : MetaNetDef() {
    *this = ::std::move(from);
  }

  inline MetaNetDef& operator=(MetaNetDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaNetDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetaNetDef* internal_default_instance() {
    return reinterpret_cast<const MetaNetDef*>(
               &_MetaNetDef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MetaNetDef* other);
  friend void swap(MetaNetDef& a, MetaNetDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaNetDef* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaNetDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MetaNetDef& from);
  void MergeFrom(const MetaNetDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MetaNetDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe2.BlobsMap blobs = 1;
  int blobs_size() const;
  void clear_blobs();
  static const int kBlobsFieldNumber = 1;
  const ::caffe2::BlobsMap& blobs(int index) const;
  ::caffe2::BlobsMap* mutable_blobs(int index);
  ::caffe2::BlobsMap* add_blobs();
  ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >*
      mutable_blobs();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >&
      blobs() const;

  // repeated .caffe2.NetsMap nets = 2;
  int nets_size() const;
  void clear_nets();
  static const int kNetsFieldNumber = 2;
  const ::caffe2::NetsMap& nets(int index) const;
  ::caffe2::NetsMap* mutable_nets(int index);
  ::caffe2::NetsMap* add_nets();
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >*
      mutable_nets();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >&
      nets() const;

  // repeated .caffe2.PlansMap plans = 4;
  int plans_size() const;
  void clear_plans();
  static const int kPlansFieldNumber = 4;
  const ::caffe2::PlansMap& plans(int index) const;
  ::caffe2::PlansMap* mutable_plans(int index);
  ::caffe2::PlansMap* add_plans();
  ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >*
      mutable_plans();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >&
      plans() const;

  // repeated .caffe2.StringMap applicationSpecificInfo = 5;
  int applicationspecificinfo_size() const;
  void clear_applicationspecificinfo();
  static const int kApplicationSpecificInfoFieldNumber = 5;
  const ::caffe2::StringMap& applicationspecificinfo(int index) const;
  ::caffe2::StringMap* mutable_applicationspecificinfo(int index);
  ::caffe2::StringMap* add_applicationspecificinfo();
  ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >*
      mutable_applicationspecificinfo();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >&
      applicationspecificinfo() const;

  // optional .caffe2.ModelInfo modelInfo = 3;
  bool has_modelinfo() const;
  void clear_modelinfo();
  static const int kModelInfoFieldNumber = 3;
  const ::caffe2::ModelInfo& modelinfo() const;
  ::caffe2::ModelInfo* release_modelinfo();
  ::caffe2::ModelInfo* mutable_modelinfo();
  void set_allocated_modelinfo(::caffe2::ModelInfo* modelinfo);

  // @@protoc_insertion_point(class_scope:caffe2.MetaNetDef)
 private:
  void set_has_modelinfo();
  void clear_has_modelinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap > blobs_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap > nets_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap > plans_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap > applicationspecificinfo_;
  ::caffe2::ModelInfo* modelinfo_;
  friend struct ::protobuf_caffe2_2fproto_2fmetanet_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fmetanet_2eproto::InitDefaultsMetaNetDefImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModelInfo

// optional string project = 1;
inline bool ModelInfo::has_project() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelInfo::set_has_project() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelInfo::clear_has_project() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelInfo::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_project();
}
inline const ::std::string& ModelInfo::project() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.project)
  return project_.GetNoArena();
}
inline void ModelInfo::set_project(const ::std::string& value) {
  set_has_project();
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.project)
}
#if LANG_CXX11
inline void ModelInfo::set_project(::std::string&& value) {
  set_has_project();
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.project)
}
#endif
inline void ModelInfo::set_project(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_project();
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.project)
}
inline void ModelInfo::set_project(const char* value, size_t size) {
  set_has_project();
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.project)
}
inline ::std::string* ModelInfo::mutable_project() {
  set_has_project();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_project() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.project)
  clear_has_project();
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_project(::std::string* project) {
  if (project != NULL) {
    set_has_project();
  } else {
    clear_has_project();
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.project)
}

// optional string modelClass = 2;
inline bool ModelInfo::has_modelclass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelInfo::set_has_modelclass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelInfo::clear_has_modelclass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelInfo::clear_modelclass() {
  modelclass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelclass();
}
inline const ::std::string& ModelInfo::modelclass() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.modelClass)
  return modelclass_.GetNoArena();
}
inline void ModelInfo::set_modelclass(const ::std::string& value) {
  set_has_modelclass();
  modelclass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.modelClass)
}
#if LANG_CXX11
inline void ModelInfo::set_modelclass(::std::string&& value) {
  set_has_modelclass();
  modelclass_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.modelClass)
}
#endif
inline void ModelInfo::set_modelclass(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modelclass();
  modelclass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.modelClass)
}
inline void ModelInfo::set_modelclass(const char* value, size_t size) {
  set_has_modelclass();
  modelclass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.modelClass)
}
inline ::std::string* ModelInfo::mutable_modelclass() {
  set_has_modelclass();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.modelClass)
  return modelclass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_modelclass() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.modelClass)
  clear_has_modelclass();
  return modelclass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_modelclass(::std::string* modelclass) {
  if (modelclass != NULL) {
    set_has_modelclass();
  } else {
    clear_has_modelclass();
  }
  modelclass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelclass);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.modelClass)
}

// optional string version = 3;
inline bool ModelInfo::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelInfo::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& ModelInfo::version() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.version)
  return version_.GetNoArena();
}
inline void ModelInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.version)
}
#if LANG_CXX11
inline void ModelInfo::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.version)
}
#endif
inline void ModelInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.version)
}
inline void ModelInfo::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.version)
}
inline ::std::string* ModelInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_version() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.version)
}

// optional string predictorType = 4 [default = "SINGLE_PREDICTOR"];
inline bool ModelInfo::has_predictortype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelInfo::set_has_predictortype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelInfo::clear_has_predictortype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelInfo::clear_predictortype() {
  predictortype_.ClearToDefaultNoArena(&::caffe2::ModelInfo::_default_predictortype_.get());
  clear_has_predictortype();
}
inline const ::std::string& ModelInfo::predictortype() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.predictorType)
  return predictortype_.GetNoArena();
}
inline void ModelInfo::set_predictortype(const ::std::string& value) {
  set_has_predictortype();
  predictortype_.SetNoArena(&::caffe2::ModelInfo::_default_predictortype_.get(), value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.predictorType)
}
#if LANG_CXX11
inline void ModelInfo::set_predictortype(::std::string&& value) {
  set_has_predictortype();
  predictortype_.SetNoArena(
    &::caffe2::ModelInfo::_default_predictortype_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.predictorType)
}
#endif
inline void ModelInfo::set_predictortype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_predictortype();
  predictortype_.SetNoArena(&::caffe2::ModelInfo::_default_predictortype_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.predictorType)
}
inline void ModelInfo::set_predictortype(const char* value, size_t size) {
  set_has_predictortype();
  predictortype_.SetNoArena(&::caffe2::ModelInfo::_default_predictortype_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.predictorType)
}
inline ::std::string* ModelInfo::mutable_predictortype() {
  set_has_predictortype();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.predictorType)
  return predictortype_.MutableNoArena(&::caffe2::ModelInfo::_default_predictortype_.get());
}
inline ::std::string* ModelInfo::release_predictortype() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.predictorType)
  clear_has_predictortype();
  return predictortype_.ReleaseNoArena(&::caffe2::ModelInfo::_default_predictortype_.get());
}
inline void ModelInfo::set_allocated_predictortype(::std::string* predictortype) {
  if (predictortype != NULL) {
    set_has_predictortype();
  } else {
    clear_has_predictortype();
  }
  predictortype_.SetAllocatedNoArena(&::caffe2::ModelInfo::_default_predictortype_.get(), predictortype);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.predictorType)
}

// optional string modelId = 5;
inline bool ModelInfo::has_modelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModelInfo::set_has_modelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModelInfo::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModelInfo::clear_modelid() {
  modelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelid();
}
inline const ::std::string& ModelInfo::modelid() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.modelId)
  return modelid_.GetNoArena();
}
inline void ModelInfo::set_modelid(const ::std::string& value) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.modelId)
}
#if LANG_CXX11
inline void ModelInfo::set_modelid(::std::string&& value) {
  set_has_modelid();
  modelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.modelId)
}
#endif
inline void ModelInfo::set_modelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.modelId)
}
inline void ModelInfo::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.modelId)
}
inline ::std::string* ModelInfo::mutable_modelid() {
  set_has_modelid();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.modelId)
  return modelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_modelid() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.modelId)
  clear_has_modelid();
  return modelid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_modelid(::std::string* modelid) {
  if (modelid != NULL) {
    set_has_modelid();
  } else {
    clear_has_modelid();
  }
  modelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelid);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.modelId)
}

// -------------------------------------------------------------------

// BlobsMap

// required string key = 1;
inline bool BlobsMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobsMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobsMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobsMap::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& BlobsMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobsMap.key)
  return key_.GetNoArena();
}
inline void BlobsMap::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.key)
}
#if LANG_CXX11
inline void BlobsMap::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.BlobsMap.key)
}
#endif
inline void BlobsMap::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BlobsMap.key)
}
inline void BlobsMap::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobsMap.key)
}
inline ::std::string* BlobsMap::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:caffe2.BlobsMap.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlobsMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.BlobsMap.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlobsMap::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobsMap.key)
}

// repeated string value = 2;
inline int BlobsMap::value_size() const {
  return value_.size();
}
inline void BlobsMap::clear_value() {
  value_.Clear();
}
inline const ::std::string& BlobsMap::value(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.BlobsMap.value)
  return value_.Get(index);
}
inline ::std::string* BlobsMap::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobsMap.value)
  return value_.Mutable(index);
}
inline void BlobsMap::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.value)
  value_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BlobsMap::set_value(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.value)
  value_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BlobsMap::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.BlobsMap.value)
}
inline void BlobsMap::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobsMap.value)
}
inline ::std::string* BlobsMap::add_value() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.BlobsMap.value)
  return value_.Add();
}
inline void BlobsMap::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.BlobsMap.value)
}
#if LANG_CXX11
inline void BlobsMap::add_value(::std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.BlobsMap.value)
}
#endif
inline void BlobsMap::add_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.BlobsMap.value)
}
inline void BlobsMap::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.BlobsMap.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BlobsMap::value() const {
  // @@protoc_insertion_point(field_list:caffe2.BlobsMap.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BlobsMap::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.BlobsMap.value)
  return &value_;
}

// -------------------------------------------------------------------

// NetsMap

// required string key = 1;
inline bool NetsMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetsMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetsMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetsMap::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& NetsMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.NetsMap.key)
  return key_.GetNoArena();
}
inline void NetsMap::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.NetsMap.key)
}
#if LANG_CXX11
inline void NetsMap::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.NetsMap.key)
}
#endif
inline void NetsMap::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.NetsMap.key)
}
inline void NetsMap::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetsMap.key)
}
inline ::std::string* NetsMap::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:caffe2.NetsMap.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetsMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.NetsMap.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetsMap::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetsMap.key)
}

// required .caffe2.NetDef value = 2;
inline bool NetsMap::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetsMap::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetsMap::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::caffe2::NetDef& NetsMap::value() const {
  const ::caffe2::NetDef* p = value_;
  // @@protoc_insertion_point(field_get:caffe2.NetsMap.value)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::NetDef*>(
      &::caffe2::_NetDef_default_instance_);
}
inline ::caffe2::NetDef* NetsMap::release_value() {
  // @@protoc_insertion_point(field_release:caffe2.NetsMap.value)
  clear_has_value();
  ::caffe2::NetDef* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::caffe2::NetDef* NetsMap::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::caffe2::NetDef;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.NetsMap.value)
  return value_;
}
inline void NetsMap::set_allocated_value(::caffe2::NetDef* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetsMap.value)
}

// -------------------------------------------------------------------

// PlansMap

// required string key = 1;
inline bool PlansMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlansMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlansMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlansMap::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& PlansMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.PlansMap.key)
  return key_.GetNoArena();
}
inline void PlansMap::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.PlansMap.key)
}
#if LANG_CXX11
inline void PlansMap::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.PlansMap.key)
}
#endif
inline void PlansMap::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.PlansMap.key)
}
inline void PlansMap::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.PlansMap.key)
}
inline ::std::string* PlansMap::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:caffe2.PlansMap.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlansMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.PlansMap.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlansMap::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlansMap.key)
}

// required .caffe2.PlanDef value = 2;
inline bool PlansMap::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlansMap::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlansMap::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::caffe2::PlanDef& PlansMap::value() const {
  const ::caffe2::PlanDef* p = value_;
  // @@protoc_insertion_point(field_get:caffe2.PlansMap.value)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::PlanDef*>(
      &::caffe2::_PlanDef_default_instance_);
}
inline ::caffe2::PlanDef* PlansMap::release_value() {
  // @@protoc_insertion_point(field_release:caffe2.PlansMap.value)
  clear_has_value();
  ::caffe2::PlanDef* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::caffe2::PlanDef* PlansMap::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::caffe2::PlanDef;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.PlansMap.value)
  return value_;
}
inline void PlansMap::set_allocated_value(::caffe2::PlanDef* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlansMap.value)
}

// -------------------------------------------------------------------

// StringMap

// required string key = 1;
inline bool StringMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringMap::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& StringMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.StringMap.key)
  return key_.GetNoArena();
}
inline void StringMap::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.StringMap.key)
}
#if LANG_CXX11
inline void StringMap::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.StringMap.key)
}
#endif
inline void StringMap::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.StringMap.key)
}
inline void StringMap::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.StringMap.key)
}
inline ::std::string* StringMap::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:caffe2.StringMap.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.StringMap.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringMap::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.StringMap.key)
}

// required string value = 2;
inline bool StringMap::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringMap::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringMap::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringMap::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& StringMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.StringMap.value)
  return value_.GetNoArena();
}
inline void StringMap::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.StringMap.value)
}
#if LANG_CXX11
inline void StringMap::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.StringMap.value)
}
#endif
inline void StringMap::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.StringMap.value)
}
inline void StringMap::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.StringMap.value)
}
inline ::std::string* StringMap::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:caffe2.StringMap.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringMap::release_value() {
  // @@protoc_insertion_point(field_release:caffe2.StringMap.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringMap::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:caffe2.StringMap.value)
}

// -------------------------------------------------------------------

// MetaNetDef

// repeated .caffe2.BlobsMap blobs = 1;
inline int MetaNetDef::blobs_size() const {
  return blobs_.size();
}
inline void MetaNetDef::clear_blobs() {
  blobs_.Clear();
}
inline const ::caffe2::BlobsMap& MetaNetDef::blobs(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.blobs)
  return blobs_.Get(index);
}
inline ::caffe2::BlobsMap* MetaNetDef::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.blobs)
  return blobs_.Mutable(index);
}
inline ::caffe2::BlobsMap* MetaNetDef::add_blobs() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.blobs)
  return blobs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >*
MetaNetDef::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.blobs)
  return &blobs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >&
MetaNetDef::blobs() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.blobs)
  return blobs_;
}

// repeated .caffe2.NetsMap nets = 2;
inline int MetaNetDef::nets_size() const {
  return nets_.size();
}
inline void MetaNetDef::clear_nets() {
  nets_.Clear();
}
inline const ::caffe2::NetsMap& MetaNetDef::nets(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.nets)
  return nets_.Get(index);
}
inline ::caffe2::NetsMap* MetaNetDef::mutable_nets(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.nets)
  return nets_.Mutable(index);
}
inline ::caffe2::NetsMap* MetaNetDef::add_nets() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.nets)
  return nets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >*
MetaNetDef::mutable_nets() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.nets)
  return &nets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >&
MetaNetDef::nets() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.nets)
  return nets_;
}

// optional .caffe2.ModelInfo modelInfo = 3;
inline bool MetaNetDef::has_modelinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaNetDef::set_has_modelinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaNetDef::clear_has_modelinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaNetDef::clear_modelinfo() {
  if (modelinfo_ != NULL) modelinfo_->Clear();
  clear_has_modelinfo();
}
inline const ::caffe2::ModelInfo& MetaNetDef::modelinfo() const {
  const ::caffe2::ModelInfo* p = modelinfo_;
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.modelInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::ModelInfo*>(
      &::caffe2::_ModelInfo_default_instance_);
}
inline ::caffe2::ModelInfo* MetaNetDef::release_modelinfo() {
  // @@protoc_insertion_point(field_release:caffe2.MetaNetDef.modelInfo)
  clear_has_modelinfo();
  ::caffe2::ModelInfo* temp = modelinfo_;
  modelinfo_ = NULL;
  return temp;
}
inline ::caffe2::ModelInfo* MetaNetDef::mutable_modelinfo() {
  set_has_modelinfo();
  if (modelinfo_ == NULL) {
    modelinfo_ = new ::caffe2::ModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.modelInfo)
  return modelinfo_;
}
inline void MetaNetDef::set_allocated_modelinfo(::caffe2::ModelInfo* modelinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete modelinfo_;
  }
  if (modelinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      modelinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, modelinfo, submessage_arena);
    }
    set_has_modelinfo();
  } else {
    clear_has_modelinfo();
  }
  modelinfo_ = modelinfo;
  // @@protoc_insertion_point(field_set_allocated:caffe2.MetaNetDef.modelInfo)
}

// repeated .caffe2.PlansMap plans = 4;
inline int MetaNetDef::plans_size() const {
  return plans_.size();
}
inline void MetaNetDef::clear_plans() {
  plans_.Clear();
}
inline const ::caffe2::PlansMap& MetaNetDef::plans(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.plans)
  return plans_.Get(index);
}
inline ::caffe2::PlansMap* MetaNetDef::mutable_plans(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.plans)
  return plans_.Mutable(index);
}
inline ::caffe2::PlansMap* MetaNetDef::add_plans() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.plans)
  return plans_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >*
MetaNetDef::mutable_plans() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.plans)
  return &plans_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >&
MetaNetDef::plans() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.plans)
  return plans_;
}

// repeated .caffe2.StringMap applicationSpecificInfo = 5;
inline int MetaNetDef::applicationspecificinfo_size() const {
  return applicationspecificinfo_.size();
}
inline void MetaNetDef::clear_applicationspecificinfo() {
  applicationspecificinfo_.Clear();
}
inline const ::caffe2::StringMap& MetaNetDef::applicationspecificinfo(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Get(index);
}
inline ::caffe2::StringMap* MetaNetDef::mutable_applicationspecificinfo(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Mutable(index);
}
inline ::caffe2::StringMap* MetaNetDef::add_applicationspecificinfo() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >*
MetaNetDef::mutable_applicationspecificinfo() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.applicationSpecificInfo)
  return &applicationspecificinfo_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >&
MetaNetDef::applicationspecificinfo() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe2

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_caffe2_2fproto_2fmetanet_2eproto__INCLUDED
